from fastapi import FastAPI, UploadFile, File, HTTPException, Body
from fastapi.responses import RedirectResponse
from pydantic import BaseModel
from typing import List, Dict, Optional
from datetime import date, timedelta
import re, random

app = FastAPI(title="Skill Planner (step unlock + carry + monthly report)", version="5.2")

# ---------------------- Company skills (10 areas, 12 weeks each) ----------------------
COMPANY_SKILLS: Dict[str, Dict] = {
    "programming_languages": {
        "keywords": ["java", "python", "c++", "c#", "javascript", "sql"],
        "syllabus": [
            "Language basics: variables/types/IO (VSCode)",
            "Control flow: if/for/while/switch (LeetCode)",
            "Functions & modularization (Debug in IDE)",
            "OOP basics: classes & objects (Udemy/YouTube)",
            "Inheritance/polymorphism/interfaces (mini project)",
            "Exceptions & debugging (IDE breakpoints)",
            "Collections & common libs (practice)",
            "Files & DB I/O (SQLite/MySQL)",
            "Intro to concurrency/multithreading",
            "Build a small project (Git)",
            "Performance & profiling",
            "Capstone demo"
        ]
    },
    "algorithms_data_structures": {
        "keywords": ["algorithm","data structure","sorting","trees","graphs"],
        "syllabus": [
            "Complexity & Big-O (MIT 6.006)",
            "Sorting: bubble/selection/insertion/quick",
            "Searching: binary search & hashing",
            "Linked list/stack/queue (from scratch)",
            "Trees: binary tree/BST (visualgo.net)",
            "Heaps/AVL (implement heapsort)",
            "Graphs: DFS/BFS",
            "Shortest paths: Dijkstra/Floyd",
            "MST: Prim/Kruskal",
            "Dynamic programming basics",
            "Advanced DP & knapsack",
            "Capstone: curated problem set"
        ]
    },
    "software_architecture": {
        "keywords": ["system design","microservices","architecture"],
        "syllabus": [
            "Architecture overview & principles",
            "Layered arch & MVC (Flask/Django mini app)",
            "Design patterns: factory/singleton/observer (UML)",
            "Microservices intro (system diagram)",
            "API gateway & service discovery (Kong/NGINX)",
            "Load balancing & high availability",
            "Database design & sharding (ER diagrams)",
            "Messaging & async (RabbitMQ/Kafka)",
            "Observability (Prometheus+Grafana)",
            "Security: AuthN/Z (JWT)",
            "Scalability/fault-tolerance cases",
            "System design presentation"
        ]
    },
    "operating_systems": {
        "keywords": ["os","linux","threads","process"],
        "syllabus": [
            "OS concepts & structure",
            "Processes & threads (Linux top/htop)",
            "CPU scheduling (simulate)",
            "IPC: pipes/message queues (C/Python)",
            "Thread sync & mutex (pthread/threading.Lock)",
            "Deadlocks & resource allocation",
            "Memory mgmt: paging/segmentation (simulate)",
            "Virtual memory & caches",
            "Filesystem basics (ext4)",
            "Disk scheduling (code)",
            "Linux commands (grep/awk/sed)",
            "Final lab: scheduling demo"
        ]
    },
    "databases": {
        "keywords": ["database","sql","mysql","postgresql","nosql"],
        "syllabus": [
            "Database fundamentals",
            "Relational model & ER diagrams",
            "SQL basics (MySQL/Postgres)",
            "SQL advanced: JOIN/aggregation",
            "Transactions & ACID",
            "Indexes & optimization (EXPLAIN)",
            "Stored procedures & triggers",
            "NoSQL: MongoDB/Redis",
            "Distributed DB & CAP",
            "Security & backups",
            "Performance tuning & caching",
            "Capstone: mini DB app"
        ]
    },
    "version_control": {
        "keywords": ["git","github","gitlab"],
        "syllabus": [
            "Git: init/add/commit (local)",
            "History & diff (log/diff)",
            "Branches & merge",
            "Conflicts & rebase",
            "Remotes: clone/fetch/pull/push",
            "Collab: fork/PR (GitHub)",
            "Tags & releases",
            "Git hooks & automation (pre-commit)",
            "GitHub Actions CI (minimal)",
            "Best practices (Git Flow)",
            "Code review workflow",
            "Capstone: multi-contributor project"
        ]
    },
    "apis_web": {
        "keywords": ["api","rest","graphql"],
        "syllabus": [
            "HTTP fundamentals (Postman)",
            "REST design (OpenAPI)",
            "Build REST (FastAPI)",
            "AuthN/AuthZ (JWT)",
            "API docs & Swagger",
            "GraphQL basics",
            "GraphQL queries & mutations",
            "API security & rate limiting",
            "Caching & performance (Redis)",
            "API testing (pytest+requests)",
            "Deployment & ops (Heroku/AWS)",
            "Capstone: publish API"
        ]
    },
    "cloud": {
        "keywords": ["aws","azure","gcp","cloud"],
        "syllabus": [
            "Cloud foundations & service models (AWS Training)",
            "VMs & containers (EC2/Compute Engine)",
            "Object storage (S3/GCS)",
            "Managed DB (RDS/Cloud SQL)",
            "VPCs/security groups/IAM",
            "Core AWS services (IAM/EC2/S3 labs)",
            "Azure & GCP overview",
            "Auto-scaling & load balancing",
            "CI/CD on cloud (CloudFormation/ARM)",
            "Monitoring & logging (CloudWatch/Stackdriver)",
            "Cost management & optimization",
            "Capstone: deploy to cloud"
        ]
    },
    "devops": {
        "keywords": ["devops","ci/cd","docker","kubernetes","jenkins"],
        "syllabus": [
            "DevOps & CI/CD fundamentals (‘The Phoenix Project’)",
            "Jenkins CI (local setup)",
            "Docker basics (hello-world)",
            "Dockerfile & image optimization",
            "Docker Compose (web+db)",
            "Kubernetes concepts (minikube)",
            "K8s deploy & Service (kubectl apply)",
            "Helm & config management",
            "Monitoring & logs (Prometheus+Grafana)",
            "Automation & pipelines (Jenkins pipeline)",
            "Release & rollback strategies",
            "Capstone: end-to-end CI/CD"
        ]
    },
    "testing_debugging": {
        "keywords": ["testing","unit test","integration test","debugging"],
        "syllabus": [
            "Testing basics & unit tests (PyTest/JUnit)",
            "Test frameworks advanced (parametrization)",
            "Integration tests & mocking",
            "Coverage & reports (coverage.py/jacoco)",
            "Debugging & logging (IDE+pdb)",
            "Debugging tools (Chrome DevTools etc.)",
            "Performance & load testing (JMeter/Locust)",
            "Automation testing (Selenium/Playwright)",
            "Security testing basics (OWASP ZAP)",
            "Continuous testing & CI (GitHub Actions)",
            "Testing best practices",
            "Capstone: end-to-end test suite"
        ]
    }
}
CODING_ORDER = list(COMPANY_SKILLS.keys())

# ---------------------- Regex + in-memory state ----------------------
EMAIL_RE = re.compile(r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}")
PHONE_RE = re.compile(r"\b(?:\+?\d[\d\s-]{7,}\d)\b")
TOKEN_RE = re.compile(r"[A-Za-z+#.]+")  # crude tokens

class ResumeData(BaseModel):
    name: Optional[str] = None
    emails: List[str] = []
    phones: List[str] = []
    skills_found: List[str] = []

class CurrentTask(BaseModel):
    id: str
    skill: str
    week_global: int
    month: int
    week_in_month: int
    start: date
    end: date
    topic: str
    prompt: str

DB: Dict[str, dict] = {}  # resume, missing, plan_all, cursor, unlock_code, report_codes

# ---------------------- Helpers ----------------------
def extract_name(raw: str) -> Optional[str]:
    for line in raw.splitlines():
        if line.lower().startswith("name:"):
            return line.split(":", 1)[1].strip()
    return None

def match_skills(tokens: List[str]) -> List[str]:
    owned = set()
    toks = [t.lower() for t in tokens]
    for skill, meta in COMPANY_SKILLS.items():
        for kw in meta["keywords"]:
            if kw.lower() in toks:
                owned.add(skill); break
    return [s for s in CODING_ORDER if s in owned]

def linear_queue(missing: List[str]) -> List[Dict]:
    q = []
    for skill in missing:
        for i, topic in enumerate(COMPANY_SKILLS[skill]["syllabus"], start=1):
            q.append({"skill": skill, "topic": topic, "topic_idx": i})
    return q

def schedule_monthly(q: List[Dict], start_date: date) -> List[Dict]:
    tasks = []
    for i, item in enumerate(q):
        month = (i // 4) + 1
        week_in_month = (i % 4) + 1
        ws = start_date + timedelta(weeks=i)
        we = ws + timedelta(days=6)
        tid = f"m{month}-w{week_in_month}-{item['skill']}-t{item['topic_idx']}"
        tasks.append({
            "id": tid, "skill": item["skill"], "topic": item["topic"],
            "week_global": i+1, "month": month, "week_in_month": week_in_month,
            "start": ws, "end": we, "done": False
        })
    return tasks

def get_current_task_obj() -> Optional[CurrentTask]:
    if "plan_all" not in DB or "cursor" not in DB: return None
    cur = DB["cursor"]; plan = DB["plan_all"]
    if cur >= len(plan): return None
    t = plan[cur]
    return CurrentTask(
        id=t["id"], skill=t["skill"], week_global=t["week_global"],
        month=t["month"], week_in_month=t["week_in_month"],
        start=t["start"], end=t["end"], topic=t["topic"],
        prompt="Have you completed this week's task? Type YES at /answer (NO will repeat this topic next week)."
    )

def ensure_plan_exists():
    if "plan_all" in DB: return
    if "missing" not in DB:
        raise HTTPException(400, "Call /missing-skills first.")
    start = date.today()
    q = linear_queue(DB["missing"])
    DB["plan_all"] = schedule_monthly(q, start_date=start)
    DB["cursor"] = 0
    DB["unlock_code"] = None
    DB["report_codes"] = {}

def gen_code() -> str:
    return f"{random.randint(100000, 999999)}"

def id_to_topic_idx(task_id: str) -> int:
    return int(task_id.split("t")[-1])

# ---------------------- Routes ----------------------
@app.get("/", include_in_schema=False)
def root():
    return RedirectResponse(url="/docs")

# Upload resume
@app.post("/upload", response_model=ResumeData)
async def upload_resume(file: UploadFile = File(...)):
    raw = (await file.read()).decode(errors="ignore")
    emails = EMAIL_RE.findall(raw)
    phones = PHONE_RE.findall(raw)
    tokens = TOKEN_RE.findall(raw)
    resume = ResumeData(
        name=extract_name(raw) or "Unknown",
        emails=["[REDACTED]"] if emails else [],
        phones=["[REDACTED]"] if phones else [],
        skills_found=match_skills(tokens)
    )
    DB["resume"] = resume.model_dump()
    return resume

# Compute missing skills (coding order)
@app.get("/missing-skills")
def missing_skills():
    if "resume" not in DB:
        raise HTTPException(400, "Upload a resume first: /upload")
    owned = set(DB["resume"]["skills_found"])
    missing = [s for s in CODING_ORDER if s not in owned]
    DB["missing"] = missing
    return {"missing_skills": missing, "order_used": CODING_ORDER}

# Get current task (auto-plan on first call)
@app.get("/current-task", response_model=CurrentTask)
def current_task():
    ensure_plan_exists()
    cur = get_current_task_obj()
    if not cur:
        raise HTTPException(404, "All tasks completed 🎉")
    return cur

# Answer YES/NO for current task — monthly code ONLY if Week 4
class AnswerBody(BaseModel):
    answer: str

@app.post("/answer")
def answer(body: AnswerBody):
    ensure_plan_exists()
    ans = body.answer.strip().lower()
    cur_idx = DB["cursor"]
    plan = DB["plan_all"]
    if cur_idx >= len(plan):
        return {"ok": True, "msg": "All tasks completed."}

    current = plan[cur_idx]
    current_month = current["month"]
    monthly_code = None
    if current["week_in_month"] == 4:
        monthly_code = gen_code()
        DB["report_codes"][current_month] = monthly_code  # month-specific key

    if ans in ("yes", "y"):
        current["done"] = True
        unlock = gen_code()
        DB["unlock_code"] = unlock
        return {
            "ok": True,
            "msg": "Great! Use this code at /unlock-next.",
            "unlock_code": unlock,
            "monthly_report_code": monthly_code,
            "month": current_month
        }

    # NO: repeat current topic next week; shift plan
    item = {"skill": current["skill"], "topic": current["topic"], "topic_idx": id_to_topic_idx(current["id"])}
    def to_q(tasks: List[dict]) -> List[Dict]:
        return [{"skill": t["skill"], "topic": t["topic"], "topic_idx": id_to_topic_idx(t["id"])} for t in tasks]
    before = plan[:cur_idx]
    after  = plan[cur_idx+1:]
    q = to_q(before + [current] + [current] + after)
    base_start = plan[0]["start"]
    new_plan = schedule_monthly(q, start_date=base_start)

    # keep 'done' flags best-effort
    def key(t): return (t["skill"], id_to_topic_idx(t["id"]))
    done_map = {key(t): t.get("done", False) for t in plan}
    for t in new_plan:
        t["done"] = done_map.get(key(t), False)

    DB["plan_all"] = new_plan
    DB["cursor"] = cur_idx + 1
    DB["unlock_code"] = None

    next_task = get_current_task_obj()
    return {
        "ok": True,
        "msg": "Noted. The same topic is scheduled again for next week.",
        "next_task": next_task,
        "monthly_report_code": monthly_code,  # None unless Week 4
        "month": current_month
    }

# Unlock next task
class UnlockBody(BaseModel):
    code: str

@app.post("/unlock-next", response_model=CurrentTask)
def unlock_next(body: UnlockBody):
    ensure_plan_exists()
    if not DB.get("unlock_code"):
        raise HTTPException(400, "No unlock code. Answer YES first.")
    if body.code.strip() != DB["unlock_code"]:
        raise HTTPException(401, "Invalid unlock code.")
    DB["unlock_code"] = None
    DB["cursor"] += 1
    cur = get_current_task_obj()
    if not cur:
        raise HTTPException(404, "All tasks completed 🎉")
    return cur

# Monthly Grow Report — shows 'done' and 'overdue' with original due week; pre-mastered skills treated as 100% and 'mastered'
@app.get("/report")
def report(month: int, code: str):
    ensure_plan_exists()
    if DB.get("report_codes", {}).get(month) != code:
        raise HTTPException(401, "Invalid monthly report code.")

    plan = DB["plan_all"]
    name = DB.get("resume", {}).get("name", "Unknown")

    # Determine pre-mastered skills (from resume)
    resume_skills = set(DB.get("resume", {}).get("skills_found", []))
    missing = set(DB.get("missing", []))
    pre_mastered = [s for s in CODING_ORDER if s not in missing]  # already had; not in missing

    # Month tasks (should be 4)
    month_tasks = [t for t in plan if t["month"] == month]

    # Completion percent for the month
    total = len(month_tasks) or 4
    done_count = sum(1 for t in month_tasks if t.get("done"))
    completion_percent = int(round(done_count / total * 100))

    # In a monthly report view, anything not done for that month is overdue.
    detailed_tasks = []
    for t in month_tasks:
        status = "done" if t.get("done") else "overdue"
        detailed_tasks.append({
            "id": t["id"],
            "skill": t["skill"],
            "topic": t["topic"],
            "original_due_week": t["week_in_month"],
            "status": status
        })

    # Skill progress: pre-mastered = 100%; others = (#done topics in plan)/12
    skills_progress = {}
    for s in CODING_ORDER:
        if s in pre_mastered:
            skills_progress[s] = 100
        else:
            done_topics = sum(1 for t in plan if t["skill"] == s and t.get("done"))
            skills_progress[s] = int(round(done_topics / 12 * 100))

    # Completed skills list includes pre-mastered + any skill reaching 100% via plan
    completed_skills = sorted(set(pre_mastered + [s for s, p in skills_progress.items() if p >= 100]))

    # Remaining skills exclude pre-mastered; show percent
    remaining_skills = {s: p for s, p in skills_progress.items() if s not in pre_mastered and p < 100}

    return {
        "name": name,
        "month": month,
        "completion_percent": completion_percent,
        "completed_skills": completed_skills,           # includes resume-owned skills
        "skills_progress_percent": skills_progress,     # chart data: pre-mastered are 100%
        "remaining_skills_percent": remaining_skills,
        "tasks": detailed_tasks                         # each has topic + original_due_week + status
    }

# Reset
@app.post("/reset")
def reset():
    DB.clear()
    return {"ok": True, "msg": "Cleared all data"}
