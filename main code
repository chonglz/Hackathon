
from fastapi import FastAPI, UploadFile, File, HTTPException, Body
from fastapi.responses import RedirectResponse, JSONResponse
from pydantic import BaseModel
from typing import List, Dict, Optional
from datetime import date, timedelta
import re, random

app = FastAPI(title="Skill Planner (Step-by-step unlock)", version="3.0")

# ---------------- Company skills in strict coding order (12 weeks each) ---------------
COMPANY_SKILLS: Dict[str, Dict] = {
    "programming_languages": {
        "keywords": ["java", "python", "c++", "c#", "javascript", "sql"],
        "syllabus": [
            "Language basics: variables/types/IO (VSCode)",
            "Control flow: if/for/while/switch (LeetCode)",
            "Functions & modularization (Debug in IDE)",
            "OOP basics: classes & objects (Udemy/YouTube)",
            "Inheritance/polymorphism/interfaces (mini project)",
            "Exceptions & debugging (IDE breakpoints)",
            "Collections & common libs (practice)",
            "Files & DB I/O (SQLite/MySQL)",
            "Intro to concurrency/multithreading",
            "Build a small project (Git)",
            "Performance & profiling",
            "Capstone demo"
        ]
    },
    "algorithms_data_structures": {
        "keywords": ["algorithm","data structure","sorting","trees","graphs"],
        "syllabus": [
            "Complexity & Big-O (MIT 6.006)",
            "Sorting: bubble/selection/insertion/quick",
            "Searching: binary search & hashing",
            "Linked list/stack/queue (from scratch)",
            "Trees: binary tree/BST (visualgo.net)",
            "Heaps/AVL (implement heapsort)",
            "Graphs: DFS/BFS",
            "Shortest paths: Dijkstra/Floyd",
            "MST: Prim/Kruskal",
            "Dynamic programming basics",
            "Advanced DP & knapsack",
            "Capstone: curated problem set"
        ]
    },
    "software_architecture": {
        "keywords": ["system design","microservices","architecture"],
        "syllabus": [
            "Architecture overview & principles",
            "Layered arch & MVC (Flask/Django mini app)",
            "Design patterns: factory/singleton/observer (UML)",
            "Microservices intro (system diagram)",
            "API gateway & service discovery (Kong/NGINX)",
            "Load balancing & HA",
            "DB design & sharding (ER)",
            "Messaging & async (RabbitMQ/Kafka)",
            "Observability (Prometheus+Grafana)",
            "Security: AuthN/Z (JWT)",
            "Scalability/fault-tolerance cases",
            "System design presentation"
        ]
    },
    "operating_systems": {
        "keywords": ["os","linux","threads","process"],
        "syllabus": [
            "OS concepts & structure",
            "Processes & threads (Linux top/htop)",
            "CPU scheduling (simulate)",
            "IPC: pipes/message queues (C/Python)",
            "Thread sync & mutex (pthread/threading.Lock)",
            "Deadlocks & resource allocation",
            "Memory mgmt: paging/segmentation (simulate)",
            "Virtual memory & caches",
            "Filesystem basics (ext4)",
            "Disk scheduling (code)",
            "Linux commands (grep/awk/sed)",
            "Final lab: scheduling demo"
        ]
    },
    "databases": {
        "keywords": ["database","sql","mysql","postgresql","nosql"],
        "syllabus": [
            "DB fundamentals",
            "Relational model & ER (draw.io)",
            "SQL basics (Workbench/psql)",
            "SQL advanced: JOIN/aggregation",
            "Transactions & ACID",
            "Indexes & optimization (EXPLAIN)",
            "Stored procedures & triggers",
            "NoSQL: MongoDB/Redis",
            "Distributed DB & CAP",
            "Security & backups (mysqldump)",
            "Performance tuning & caching",
            "Capstone: mini DB app"
        ]
    },
    "version_control": {
        "keywords": ["git","github","gitlab"],
        "syllabus": [
            "Git: init/add/commit (local)",
            "History & diff (log/diff)",
            "Branches & merge",
            "Conflicts & rebase",
            "Remotes: clone/fetch/pull/push",
            "Collab: fork/PR (GitHub)",
            "Tags & releases",
            "Git hooks & automation (pre-commit)",
            "GitHub Actions CI (minimal)",
            "Best practices (Git Flow)",
            "Code review workflow",
            "Capstone: multi-contributor"
        ]
    },
    "apis_web": {
        "keywords": ["api","rest","graphql"],
        "syllabus": [
            "HTTP fundamentals (Postman)",
            "REST design (OpenAPI)",
            "Build REST (FastAPI)",
            "AuthN/AuthZ (JWT)",
            "API docs & Swagger",
            "GraphQL basics",
            "GraphQL queries & mutations",
            "Security & rate limiting",
            "Caching & performance (Redis)",
            "API testing (pytest+requests)",
            "Deployment & ops (Heroku/AWS)",
            "Capstone: publish API"
        ]
    },
    "cloud": {
        "keywords": ["aws","azure","gcp","cloud"],
        "syllabus": [
            "Cloud foundations & service models (AWS Training)",
            "VMs & containers (EC2/Compute Engine)",
            "Object storage (S3/GCS)",
            "Managed DB (RDS/Cloud SQL)",
            "VPCs/security groups/IAM",
            "Core AWS services (IAM/EC2/S3 labs)",
            "Azure & GCP overview",
            "Auto-scaling & load balancing",
            "CI/CD on cloud (CloudFormation/ARM)",
            "Monitoring & logging (CloudWatch/Stackdriver)",
            "Cost mgmt & optimization",
            "Capstone: deploy to cloud"
        ]
    },
    "devops": {
        "keywords": ["devops","ci/cd","docker","kubernetes","jenkins"],
        "syllabus": [
            "DevOps & CI/CD fundamentals (â€˜The Phoenix Projectâ€™)",
            "Jenkins CI (local setup)",
            "Docker basics (hello-world)",
            "Dockerfile & image optimization",
            "Docker Compose (web+db)",
            "Kubernetes concepts (minikube)",
            "K8s deploy & Service (kubectl apply)",
            "Helm & config management",
            "Monitoring & logs (Prometheus+Grafana)",
            "Automation & pipelines (Jenkins pipeline)",
            "Release & rollback",
            "Capstone: end-to-end CI/CD"
        ]
    },
    "testing_debugging": {
        "keywords": ["testing","unit test","integration test","debugging"],
        "syllabus": [
            "Testing basics & unit tests (PyTest/JUnit)",
            "Framework advanced (parametrization)",
            "Integration tests & mocking",
            "Coverage & reports (coverage/jacoco)",
            "Debugging & logging (IDE+pdb)",
            "Debugging tools (DevTools etc.)",
            "Performance/load (JMeter/Locust)",
            "Automation (Selenium/Playwright)",
            "Security testing (OWASP ZAP)",
            "Continuous testing (GitHub Actions)",
            "Best practices",
            "Capstone: E2E test suite"
        ]
    }
}
CODING_ORDER = list(COMPANY_SKILLS.keys())

# ---------------- Regex + in-memory state ----------------
EMAIL_RE = re.compile(r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}")
PHONE_RE = re.compile(r"\b(?:\+?\d[\d\s-]{7,}\d)\b")
TOKEN_RE = re.compile(r"[A-Za-z+#.]+")  # crude tokens

class ResumeData(BaseModel):
    name: Optional[str] = None
    emails: List[str] = []
    phones: List[str] = []
    skills_found: List[str] = []

class CurrentTask(BaseModel):
    id: str
    skill: str
    week_global: int
    month: int
    week_in_month: int
    start: date
    end: date
    topic: str
    prompt: str  # what to ask the user

DB: Dict[str, dict] = {}  # resume, missing, plan_all, cursor, pending_code

def extract_name(raw: str) -> Optional[str]:
    for line in raw.splitlines():
        if line.lower().startswith("name:"):
            return line.split(":", 1)[1].strip()
    return None

def match_skills(tokens: List[str]) -> List[str]:
    owned = set()
    toks = [t.lower() for t in tokens]
    for skill, meta in COMPANY_SKILLS.items():
        for kw in meta["keywords"]:
            if kw.lower() in toks:
                owned.add(skill); break
    return [s for s in CODING_ORDER if s in owned]

def linear_queue(missing: List[str]) -> List[Dict]:
    q = []
    for skill in missing:
        for i, topic in enumerate(COMPANY_SKILLS[skill]["syllabus"], start=1):
            q.append({"skill": skill, "topic": topic, "topic_idx": i})
    return q

def schedule(q: List[Dict], start_date: date) -> List[Dict]:
    tasks = []
    for i, item in enumerate(q):  # i from 0
        month = (i // 4) + 1
        week_in_month = (i % 4) + 1
        ws = start_date + timedelta(weeks=i)
        we = ws + timedelta(days=6)
        tid = f"m{month}-w{week_in_month}-{item['skill']}-t{item['topic_idx']}"
        tasks.append({
            "id": tid, "skill": item["skill"], "topic": item["topic"],
            "week_global": i+1, "month": month, "week_in_month": week_in_month,
            "start": ws, "end": we, "done": False
        })
    return tasks

def get_current_task_obj() -> Optional[CurrentTask]:
    if "plan_all" not in DB or "cursor" not in DB: return None
    cur = DB["cursor"]
    plan = DB["plan_all"]
    if cur >= len(plan): return None
    t = plan[cur]
    return CurrentTask(
        id=t["id"], skill=t["skill"], week_global=t["week_global"],
        month=t["month"], week_in_month=t["week_in_month"],
        start=t["start"], end=t["end"], topic=t["topic"],
        prompt="Have you completed this week's task? Type YES at /answer to receive an unlock code."
    )

# ------------- Helpers for unlock code -------------
def gen_code() -> str:
    return f"{random.randint(100000, 999999)}"

# ---------------- Routes ----------------
@app.get("/", include_in_schema=False)
def root():
    return RedirectResponse(url="/docs")

# 1) Upload resume
@app.post("/upload", response_model=ResumeData)
async def upload_resume(file: UploadFile = File(...)):
    raw = (await file.read()).decode(errors="ignore")
    emails = EMAIL_RE.findall(raw)
    phones = PHONE_RE.findall(raw)
    tokens = TOKEN_RE.findall(raw)

    _ = EMAIL_RE.sub("[EMAIL]", raw)
    _ = PHONE_RE.sub("[PHONE]", _)

    resume = ResumeData(
        name=extract_name(raw) or "Unknown",
        emails=["[REDACTED]"] if emails else [],
        phones=["[REDACTED]"] if phones else [],
        skills_found=match_skills(tokens)
    )
    DB["resume"] = resume.model_dump()
    return resume

# 2) Show missing skills (coding order)
@app.get("/missing-skills")
def missing_skills():
    if "resume" not in DB:
        raise HTTPException(400, "Upload a resume first: /upload")
    owned = set(DB["resume"]["skills_found"])
    required = CODING_ORDER
    missing = [s for s in required if s not in owned]
    DB["missing"] = missing
    return {"missing_skills": missing, "order_used": required}

# 3) Build plan & show ONLY the first task
class PlanRequest(BaseModel):
    start_date: Optional[date] = None

@app.post("/plan", response_model=CurrentTask)
def build_plan(req: PlanRequest = Body(default=PlanRequest())):
    if "missing" not in DB:
        raise HTTPException(400, "Call /missing-skills first")
    start = req.start_date or date.today()
    q = linear_queue(DB["missing"])
    plan = schedule(q, start_date=start)
    DB["plan_all"] = plan
    DB["cursor"] = 0
    DB["pending_code"] = None
    cur = get_current_task_obj()
    if not cur:
        raise HTTPException(400, "No tasks generated")
    return cur

# 4) Get current task again (for display)
@app.get("/current-task", response_model=CurrentTask)
def current_task():
    cur = get_current_task_obj()
    if not cur:
        raise HTTPException(404, "All tasks completed ðŸŽ‰")
    return cur

# 5) User answers if done -> only needs to type YES
class AnswerBody(BaseModel):
    answer: str

@app.post("/answer")
def answer(body: AnswerBody):
    if "plan_all" not in DB or "cursor" not in DB:
        raise HTTPException(400, "Build plan first: /plan")
    ans = body.answer.strip().lower()
    if ans not in ("yes", "y"):
        return {"ok": False, "msg": "Got it. Come back when it's done."}
    # mark current as done
    cur = DB["cursor"]
    plan = DB["plan_all"]
    if cur >= len(plan):
        return {"ok": True, "msg": "All tasks already completed."}
    plan[cur]["done"] = True
    # generate unlock code
    code = gen_code()
    DB["pending_code"] = code
    return {
        "ok": True,
        "msg": "Great job! Use this code to unlock the next task at /unlock-next",
        "unlock_code": code,
        "current_task_id": plan[cur]["id"]
    }

# 6) Unlock next by code (reveals ONLY the next task)
class UnlockBody(BaseModel):
    code: str

@app.post("/unlock-next", response_model=CurrentTask)
def unlock_next(body: UnlockBody):
    if "plan_all" not in DB or "cursor" not in DB:
        raise HTTPException(400, "Build plan first: /plan")
    if not DB.get("pending_code"):
        raise HTTPException(400, "No pending code. Complete the current task first at /answer with YES.")
    if body.code.strip() != DB["pending_code"]:
        raise HTTPException(401, "Invalid code. Please re-enter the correct unlock code.")
    # advance pointer
    DB["pending_code"] = None
    DB["cursor"] += 1
    cur = get_current_task_obj()
    if not cur:
        raise HTTPException(404, "All tasks completed ðŸŽ‰")
    return cur

# 7) Reset
@app.post("/reset")
def reset():
    DB.clear()
    return {"ok": True, "msg": "Cleared resume, gaps, plan, cursor, code"}
